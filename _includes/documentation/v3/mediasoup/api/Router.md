## Router
{: #Router}

A router holds a multiparty RTC (Real-Time Communication) conference.


### Dictionaries
{: #Router-dictionaries}

<section markdown="1">

#### RouterMediaCodec
{: #Router-RouterMediaCodec .code}

<div markdown="1" class="table-wrapper L3">

Field                    | Type    | Description   | Required | Default
------------------------ | ------- | ------------- | -------- | ---------
`kind`                   | String  | Media kind ("audio" or "video"). | Yes |
`mimeType`               | String  | The codec MIME type, i.e. "audio/opus", "video/VP8". The list of mediasoup supported codecs is available in the [mediasoup/lib/supportedRtpCapabilities.js](https://github.com/versatica/mediasoup/blob/v3/lib/supportedRtpCapabilities.js) file. | Yes |
`clockRate`              | Number  | Codec clock rate expressed in Hertz. | Yes |
`channels`               | Number  | The number of channels (mono=1, stereo=2) for audio codecs. | No | 1
`parameters`             | Dictionary | Codec-specific parameters available for signaling. | No |

</div>

<div markdown="1" class="note warn">
Feature codecs such as RTX or FEC must **NOT** be placed into Router `mediaCodecs`.
</div>

</section>


### Properties
{: #Router-properties}

<section markdown="1">

#### router.id
{: #router-id .code}

* `@type` String, read only

Router identifier.

#### router.closed
{: #router-closed .code}

* `@type` Boolean, read only

Whether the router is closed.

#### router.rtpCapabilities
{: #router-rtpCapabilities .code}

* `@type` [RTCRtpCapabilities](https://draft.ortc.org/#rtcrtpcapabilities*), read only

An Object with the RTP capabilities of the router.

</section>


### Methods
{: #Router-methods}

<section markdown="1">

#### router.close()
{: #router-close .code}

Closes the router, including all its transports and rtpObservers. It emits an "observer:close" event.

#### router.getPeerByName(name)
{: #router-getPeerByName .code}

Retrieves the [Peer](#Peer) with the given `name`, or `undefined` if not found.

<div markdown="1" class="table-wrapper L3">

Argument   | Type    | Description | Required | Default 
---------- | ------- | ----------- | -------- | ----------
`name`     | String  | Peer name. | Yes |

</div>

#### router.receiveRequest(request)
{: #router-receiveRequest .code}

Provide the `router` with a [mediasoup protocol](/documentation/v2/mediasoup-protocol/) request payload (commonly generated by mediasoup-client).

<div markdown="1" class="table-wrapper L3">

Argument   | Type    | Description | Required | Default 
---------- | ------- | ----------- | -------- | ----------
`request`  | Object  | mediasoup protocol request. | Yes |

</div>

<div markdown="1" class="note">
Just mediasoup protocol requests with "router" target must be given to this method, meaning that the mediasoup protocol payload:

* must have `target: "router"`, and
* must **NOT** have `notification: true`.
</div>

The method returns a Promise resolving to a mediasoup protocol response payload that must be sent back to the request originator.

Usage example:

```javascript
// Here we assume a custom WebSocket based signaling protocol.
// * request: A mediasoup protocol request payload with target: "router".
// * accept: A function to tell our signaling protocol to accept the request.
// * reject: A function to tell our signaling protocol to reject the request.
function handleRequestFromMediasoupClient(request, accept, reject)
{
  switch (request.method)
  {
    case "queryRoom":
    {
      mediasoupRoom.receiveRequest(request)
        .then((response) => accept(response))
        .catch((error) => reject(500, error.toString()));

      break;
    }

    case "join":
    {
      const { peerName, spy } = request;

      // Here we may want to check whether `spy` is `true` and allow or reject
      // this join request based on app logic/policy.

      mediasoupRoom.receiveRequest(request)
        .then((response) =>
        {
          // Get the new mediasoup Peer instance.
          const peer = mediasoupRoom.getPeerByName(peerName);

          console.info("new peer joined the router: %o", peer);

          accept(response);
        })
        .catch((error) => reject(500, error.toString()));

      break;
    }
  }
}
```

</section>


### Events
{: #Router-events}

The Router class inherits from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).

<section markdown="1">

#### router.on("close", fn(appData))
{: #router-on-close .code}

Emitted when the `router` is closed.

<div markdown="1" class="table-wrapper L3">

Argument  | Type    | Description   
--------- | ------- | ----------------
`appData` | Any     | Custom app data.

</div>

#### router.on("newpeer", peer)
{: #router-on-newpeer .code}

Emitted when a new `peer` is created.

<div markdown="1" class="table-wrapper L3">

Argument | Type    | Description   
-------- | ------- | ----------------
`peer`   | [Peer](#Peer) | New `peer`.

</div>

</section>
